use core
use core.encoding {osad}

main :: (args: [] cstr) {
    if args.length == 0 {
        eprintf("""Usage:
    onyx-doc-gen <file.odoc> [output=doc.html]\n""");
        os.exit(1);
    }
    
    odoc_file := string.as_str(args[0]);
    contents  := os.get_contents(odoc_file);
    if !contents {
        eprintf("""Failed to read contents of '{}'.\n""", odoc_file);
        os.exit(1);
    }

    destination_file := "doc.html";
    if args.length == 2 {
        destination_file = string.as_str(args[1]);
    }

    maybe_docs := osad.deserialize(doc.Doc, contents);
    if !maybe_docs {
        eprintf("Failed to parse documentation file.\n");
        return;
    }

    docs := maybe_docs->unwrap();

    for os.with_file(destination_file, .Write) {
        w := io.writer_make(it);
        defer io.writer_free(&w);

        write_docs(&docs, &w);
    }
}

write_docs :: (docs: &doc.Doc, w: &io.Writer) {
    io.write(w, """
<!DOCTYPE html>
<html>
    <head>
        <title>Generated Documentation</title>
        
        <style>
            * {
                padding: 0;
                margin: 0;
            }

            body {
                /*background-color: #070707;
                color: #ffffff;*/
            }

            a {
                text-decoration: none;
                color: #ddddff;
            }

            a:visited {
                text-decoration: none;
                color: #ddddff;
            }

            pre > code {
                color: #ffffff;
                background-color: #111;
                border: 1px solid #222222;
            }

            pre {
                margin: 4px 0;
            }
        </style>
    </head>

    <body>
        <h1>Table of Contents</h1>
""");

    for& docs.packages {
        if it.name == it.qualified_name {
            // The package is a root package
            output_package_tree(w, docs.packages, it);
        }
    }

    for& docs.packages {
        output_package_list(w, docs, it);
    }

    io.write(w, "</body></html>");
}

output_package_tree :: (w: &io.Writer, packages: [] doc.Doc_Package, p: &doc.Doc_Package, depth := 0) {
    io.write_format(w, "<p style=\"position: relative; left: {}px\"><a href=\"#{}\">{}</a></p>",
        depth * 20,
        p.qualified_name,
        p.name);

    for p.subpackages {
        output_package_tree(w, packages, &packages[it], depth + 1);
    }
}

output_package_list :: (w: &io.Writer, docs: &doc.Doc, p: &doc.Doc_Package) {
    io.write_format(w, "<div id=\"{}\">", p.qualified_name);
    io.write_format(w, "<h1>{}</h1>", p.qualified_name);

    io.write_format(w, "<div style=\"position: relative; left: 50px\">");
    for iter.as_iter(docs.procedures)
        ->filter(p, (it, p) => cast(u32, it.package_id) == ~~p.id)
    {
        io.write(w, "<div style=\"margin-bottom: 12px;\">");
        io.write_format(w, "<h3>{}</h3>", it.name);
        io.write_format(w, "<p>{}:{}</p>", docs.files[it.location.file_id].name, it.location.line);

        if it.flags & .Is_Overloaded {
            for& p: it.overloads {
                p.name = it.name;
                output_procedure_definition(w, p);
            }

        } else {
            output_procedure_definition(w, it);
        }

        io.write(w, "</div>");
    }

    io.write(w, "</div>");
    io.write(w, "</div>");
}

output_procedure_definition :: (w: &io.Writer, p: &doc.Doc_Procedure) {
    io.write(w, "<pre><code>");
    io.write(w, "{} :: {}(", p.name, "macro " if p.flags&.Is_Macro else "");

    for& param: p.params {
        if !#first do io.write(w, ", ");

        io.write(w, param.name);

        if param.type {
            io.write(w, ": {}", param.type);
        }
    }

    io.write(w, ") -> {}", p.return_type);
    io.write(w, "</code></pre>");
}
