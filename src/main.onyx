use core
use core.encoding {osad}

#load "./markdown"

generate_link_from_source :: (s: doc.Doc_Location, docs: &doc.Doc) =>
    tprintf("https://github.com/onyx-lang/onyx/tree/master{}#L{}",
        string.advance(docs.files[s.file_id].name, "/usr/share/onyx".count),
        s.line);

main :: (args: [] cstr) {
    if args.length == 0 {
        eprintf("""Usage:
    onyx-doc-gen <file.odoc> [output_folder=generated]\n""");
        os.exit(1);
    }
    
    odoc_file := string.as_str(args[0]);
    contents  := os.get_contents(odoc_file);
    if !contents {
        eprintf("""Failed to read contents of '{}'.\n""", odoc_file);
        os.exit(1);
    }

    destination_folder := "generated";
    if args.length == 2 {
        destination_folder = string.as_str(args[1]);
    }

    maybe_docs := osad.deserialize(doc.Doc, contents);
    if !maybe_docs {
        eprintf("Failed to parse documentation file.\n");
        return;
    }

    docs := maybe_docs->unwrap();

    generate_docs(&docs, destination_folder);
}

generate_docs :: (docs: &doc.Doc, destination_folder: str) {
    if os.dir_exists(destination_folder) {
        log(.Info, tprintf("Removing old '{}' directory.", destination_folder));
        os.remove_directory(destination_folder);
    }

    log(.Info, tprintf("Creating '{}'.", destination_folder));
    os.dir_create(destination_folder);

    generate_static_folder(destination_folder);

    package_folder := tprintf("{}/packages", destination_folder);
    log(.Info, tprintf("Creating '{}'.", package_folder));
    os.dir_create(package_folder);

    for& p: docs.packages {
        p_html := generate_package_html_file(docs, p);

        for os.with_file(tprintf("{}/{}.html", package_folder, p.qualified_name), .Write) {
            io.stream_write(it, p_html);
            log(.Info, tprintf("Created '{}.html'", p.qualified_name));
        }
    }
}

generate_static_folder :: (destination_folder: str) {
    static_folder := tprintf("{}/static", destination_folder);
    os.dir_create(static_folder);

    for os.with_file(tprintf("{}/style.css", static_folder), .Write) {
        io.stream_write(it, #file_contents "./parts/style.css");
    }

    for os.with_file(tprintf("{}/logo_256.png", static_folder), .Write) {
        io.stream_write(it, #file_contents "./parts/logo_256.png");
    }

    for os.with_file(tprintf("{}/highlight.min.css", static_folder), .Write) {
        io.stream_write(it, #file_contents "./parts/highlight.min.css");
    }

    for os.with_file(tprintf("{}/highlight.min.js", static_folder), .Write) {
        io.stream_write(it, #file_contents "./parts/highlight.min.js");
    }

    for os.with_file(tprintf("{}/script.js", static_folder), .Write) {
        io.stream_write(it, #file_contents "./parts/script.js");
    }
}

generate_package_html_file :: (docs: &doc.Doc, p: &doc.Doc_Package) -> str {
    output: dyn_str;
    conv.format(&output, """
<html class="dark-mode">
    <head>
        <title>Package {}</title>

        <link rel="stylesheet" href="/static/highlight.min.css" />
        <link rel="stylesheet" href="/static/style.css" />
        <script src="/static/highlight.min.js"></script>
        <script src="/static/script.js"></script>
    </head>

    <body>
""", p.qualified_name);

    string.append(&output, #file_contents "./parts/navbar.html");

    string.append(&output, "<main>");

    {
        sidebar := build_package_tree_sidebar(docs, p.id);
        defer delete(&sidebar);

        string.append(&output, sidebar);
    }

    string.append(&output, "<div class=\"main-view\">");

    conv.format(&output, "<h1>Package {}</h1>", p.qualified_name);


    structs := filter_and_sort(docs.structures, p);
    for structs {
        output_entity_header(docs, it, &output);

        output_struct_definition(docs, it, &output);

        output_entity_description(it, &output);
        
        string.append(&output, "</div>");
    }

    procs := filter_and_sort(docs.procedures, p);
    for procs {
        output_entity_header(docs, it, &output);

        if it.flags & .Is_Overloaded {
            for& p: it.overloads {
                p.name = it.name;
                output_procedure_definition(docs, p, &output);
            }

        } else {
            output_procedure_definition(docs, it, &output);
        }

        output_entity_description(it, &output);

        string.append(&output, "</div>");
    }

    string.append(&output, "</div>");

    build_symbol_sidebar(
        iter.concat(
            iter.as_iter(structs)->map(x => x.name),
            iter.as_iter(procs)->map(x => x.name)),
        &output);

    string.append(&output, "</main>");

    string.append(&output, """
<script>
    window.addEventListener("load", () => hljs.highlightAll());
</script>

</body>
</html>
""");
    return output;
}

filter_and_sort :: (arr: [] $T, p: &doc.Doc_Package) -> [] &T {
    output := iter.as_iter(arr, by_pointer=true)
        |> iter.filter(x => x.visibility != .Local)
        |> iter.filter(p, (it, p) => cast(u32, it.package_id) == ~~p.id)
        |> iter.to_array();

    array.sort(output, (x, y) => {
        if x.visibility != y.visibility {
            return cast(i32, x.visibility) - cast(i32, y.visibility);
        }

        return string.compare(x.name, y.name);
    });

    return output;
}

output_entity_header :: (docs: &doc.Doc, ent: &doc.Doc_Entity, output: &dyn_str) {
    conv.format(output, "<div id=\"{}\" class=\"package-entry\">", ent.name);
    string.append(output, "<div class=\"entry-header\">");

    string.append(output, "<div>");
    if ent.visibility != .Public {
        conv.format(output, "<span class=\"visibility-badge\">#{}</span>", ent.visibility);
    }
    conv.format(output, "<span class=\"entry-name\">{}</span>", ent.name);
    string.append(output, "</div>");

    conv.format(output, "<span class=\"entry-source\"><a href=\"{}\">source</a></span>", generate_link_from_source(ent.location, docs));
    string.append(output, "</div>");
}

output_entity_description :: (ent: &doc.Doc_Entity, output: &dyn_str) {
    string.append(output, "<div class=\"description-container\">");
    if !ent.notes {
        string.append(output, "<i>No documentation provided.</i>");
    } else {
        generated_markup := markdown.translate_to_html(markdown.indent_markdown_deindent(ent.notes));
        defer delete(&generated_markup);

        string.append(output, generated_markup);
    }

    string.append(output, "</div>");
}

output_procedure_definition :: (docs: &doc.Doc, p: &doc.Doc_Procedure, out: &dyn_str) {
    string.append(out, "<div class=\"source-definition\">");
    conv.format(out, "<pre class=\"hljs language-onyx\"><code>");

    conv.format(out, "{} :: {}(",
        p.name,
        "macro " if p.flags&.Is_Macro else "");

    for& param: p.params {
        if !#first do string.append(out, ", ");

        string.append(out, param.name);

        if param.type {
            conv.format(out, ": {}", param.type);
        }
    }

    conv.format(out, ") -> {}", p.return_type);
    string.append(out, "</code></pre>");

    source_destination := generate_link_from_source(p.location, docs);
    string.append(out, "<div class=\"source-link\">");
    conv.format(out, "<a href=\"{}\">source</a>", source_destination);
    string.append(out, "</div>");

    string.append(out, "</div>");
}

output_struct_definition :: (docs: &doc.Doc, s: &doc.Doc_Structure, out: &dyn_str) {
    string.append(out, "<div class=\"source-definition\">");
    conv.format(out, "<pre class=\"hljs language-onyx\"><code>");

    conv.format(out, "{} :: struct", s.name);

    if s.polymorph_arguments {
        string.append(out, " (");
        for& p: s.polymorph_arguments {
            if !#first do string.append(out, ", ");

            conv.format(out, "{}: {}", p.name, p.type);
        }
        string.append(out, ")");
    }

    string.append(out, " {\n");

    for& member: s.members {
        string.append(out, "    ");
        string.append(out, member.name);

        if member.type {
            conv.format(out, ": {};", member.type);
        }

        string.append(out, "\n");
    }

    string.append(out, "}");
    string.append(out, "</code></pre>");

    source_destination := generate_link_from_source(s.location, docs);
    string.append(out, "<div class=\"source-link\">");
    conv.format(out, "<a href=\"{}\">source</a>", source_destination);
    string.append(out, "</div>");

    string.append(out, "</div>");
}

build_navbar :: (docs: &doc.Doc) -> str {
    return #file_contents "./parts/navbar.html";
}

build_package_tree_sidebar :: (docs: &doc.Doc, active_package: doc.Doc_Package.Id) -> str {
    log(.Info, "Generating package sidebar.");

    output: dyn_str;
    string.append(&output, "<div class=\"package-sidebar\">");

    string.append(&output, "<h1>Package Tree</h1>");
    
    tlp := iter.as_iter(docs.packages, by_pointer=true)
            |> iter.filter(x => cast(i32, x.parent) == -1)
            |> iter.to_array()
            |> array.sort((x, y) => string.compare(x.name, y.name));
    defer delete(&tlp);

    for p: tlp {
        recurse(docs, &output, p, active_package);
    }

    string.append(&output, "</div>");

    return output;

    recurse :: (docs: &doc.Doc, dest: &dyn_str, p: &doc.Doc_Package, active_package: doc.Doc_Package.Id) {
        conv.format(dest,
            "<a href=\"/packages/{}.html\"><div class=\"item {}\">{}</div></a>",
            p.qualified_name,
            "active" if cast(u32, active_package) == ~~p.id else "",
            p.name);

        if p.subpackages {
            string.append(dest, "<div class=\"container\">");

            context->set_user_data(docs);
            array.sort(p.subpackages, (x, y) => {
                docs := context->get_user_data(doc.Doc);
                return string.compare(docs.packages[~~x].name, docs.packages[~~y].name);
            });

            for p.subpackages {
                recurse(docs, dest, &docs.packages[~~it], active_package);
            }
            string.append(dest, "</div>");
        }
    }
}

build_symbol_sidebar :: (symbols: Iterator(str), output: &dyn_str) {
    string.append(output, "<div class=\"symbol-sidebar\">");
    string.append(output, "<h1>Symbols</h1>");

    for symbols {
        conv.format(output, "<a href=\"#{}\"><div class=\"symbol-link\">{}</div></a>", it, it);
    }

    string.append(output, "</div>");
}

